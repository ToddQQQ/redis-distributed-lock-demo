分布式锁

===========================
怎么实现一个 Redis 分布式锁？
	1.	加锁
	•	用 SET key value NX PX ttl：NX 确保互斥，PX 确保自动过期。
	•	Redis 单线程 → 命令天然原子。
 
      2.	解锁
      •	必须判断是不是自己持有的锁再删除 → 两步操作要保证原子性。
      •	用 Lua 脚本：if get(key)==value then del(key)。
      
          3.	过期问题
        	•	如果线程挂了，过期时间到 → 锁能自动释放。
        	•	但如果业务没完成就过期 → 可能被别人抢走。
        	•	解决：Redisson 的“看门狗”，加锁后后台线程定时续期（PEXPIRE）。
           
                	4.	可重入
                	•	同一线程多次进入 → 要支持计数器。
                	•	Redisson 的做法：Redis Hash 里 field=线程唯一标识，value=计数。
                 
                    	5.	阻塞锁
                    	•	没抢到 → 简单实现：自旋重试。
                    	•	Redisson 做法：订阅频道，等锁释放时收到通知，再去抢。
                     
                        	6.	主从复制问题
                        	•	主节点写成功但挂掉 → 从节点没同步 → 锁丢失。
                        	•	解决：多主一致加锁（RedLock 算法）。
                         
                            	7.	RedLock
                            	•	在 N 个独立 Redis 主节点上加锁，必须多数成功才算加锁成功。
                            	•	缺点：时钟漂移、GC pause、运维复杂，所以生产上不常用。
===========================================================================================================================
	1.	加锁：SET key value NX PX（原子）
	2.	解锁：判断 + 删除，用 Lua 保证原子性
	3.	锁过期 → 看门狗续期机制（守护线程，Redisson 实现）
	4.	可重入锁 → Redis Hash 存计数（Redisson 实现）
	5.	阻塞锁 → 发布订阅/自旋（Redisson 实现）
	6.	主从复制可能丢锁 → RedLock 算法（半数以上成功）
	7.	红锁的不足 → 一致性、时钟漂移、GC pause 问题
===========================================================================================================================

1. 基本实现思路：Redis SETNX
在 Redis 里，可以用
SET key value NX PX <过期时间>
来加锁。
NX 保证 key 不存在时才能加，相当于 SETNX。

PX 设置过期时间，避免线程挂了锁无法释放。


由于这是 Redis 的单条命令，Redis 是单线程执行的，所以它天然是原子性的，不需要 Lua 脚本。



2. 解锁要注意原子性
加锁之后必须解锁。解锁要先判断是不是当前线程持有的锁，再删除。
这是两步操作，必须保证原子性。
做法：写一个 Lua 脚本，判断 value 是否是当前线程的唯一标识（线程 ID 或 UUID），是才删除。
例如：
if redis.call("get", KEYS[1]) == ARGV[1] then
  return redis.call("del", KEYS[1])
else
  return 0
end

3. 锁超时问题与看门狗机制
如果线程挂了，过期时间到，锁会自动释放，这是好事。
但如果业务没执行完，锁就过期释放了，其他线程可能提前拿到锁，出问题。
解决办法：看门狗机制（这是 Redisson 的实现，不是 Redis 原生的）。
加锁成功后，启动一个定时任务（守护线程），定期对锁执行 PEXPIRE 续期。


只要业务线程还活着，锁就不会过期。

如果业务线程挂了，JVM 会把守护线程自动终止，锁不会再续期，最终释放。



4. 可重入锁
如果同一个线程在方法 A 获取了锁，又调用方法 B，而 B 也要获取同一把锁，就需要支持可重入。否则会造成死锁。
实现方式：
本地锁（如 synchronized、ReentrantLock）都有计数器：每重入一次 +1，释放一次 -1，直到 0 才真正释放。


分布式锁也要有计数器。


Redisson 的实现：
使用 Redis 的 Hash 结构：


Key：锁名


Field：线程唯一标识（线程 ID + UUID，避免集群环境下线程 ID 重复）


Value：重入计数


每次同一个线程重入，Value +1；释放一次，Value -1；减到 0 才释放锁。


另一种实现：
Redis 里仍用 String 存锁，


在服务本地用 ConcurrentHashMap 维护计数器来支持可重入。



5. 阻塞锁
如果线程没拿到锁，可以有两种做法：
简单实现：自旋，不断重试。

Redisson 的实现：

没拿到锁的线程订阅一个频道并阻塞等待；

持锁线程释放锁时，发布消息唤醒订阅者；

唤醒的线程再去尝试加锁；

可以设置超时时间，避免无限等待。



6. 主从架构下的锁丢失问题
Redis 主从复制是异步的：
客户端执行 SETNX 成功写入主节点，但主节点宕机，还没同步给从节点；

从节点提升为主后，锁数据丢失；

其他线程还能加锁成功，导致多个线程同时拿到锁，违背互斥性。

解决办法：在多个独立主节点上加锁，一致性要求更高。

7. RedLock（红锁）
Redis 作者提出了 RedLock 算法：
Redis 部署多个独立主节点；

加锁时必须在半数以上节点加锁成功才算成功；

保证即使部分节点挂了，也不会出现多个客户端同时加锁成功的情况；

超过一定时间未加锁成功就放弃，避免等待过长。

优点：在多主节点架构下保证互斥性。
缺点：
不同节点时钟可能不一致，仍有风险；

JVM 有 GC 停顿，可能导致看门狗续期失败，锁提前过期；

RedLock 要求多个独立主节点，运维复杂，一致性也难保证。

所以 红锁并不常用。大多数公司要么自己用 Redis 基础命令封装简单分布式锁，要么直接用 Redisson。
























