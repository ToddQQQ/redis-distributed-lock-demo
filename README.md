# 分布式锁

## 如何实现一个 Redis 分布式锁？

### 1. 加锁
- 使用命令：`SET key value NX PX ttl`
  - `NX`：保证互斥（只有 key 不存在时才能设置成功）。
  - `PX`：设置过期时间，避免线程挂了锁无法释放。
- Redis 是单线程执行 → 这条命令天然原子。

### 2. 解锁
- 必须保证只有持有锁的线程才能解锁 → 两步操作需要保证原子性。
- 使用 Lua 脚本来保证原子操作：
```lua
if redis.call("get", KEYS[1]) == ARGV[1] then
  return redis.call("del", KEYS[1])
else
  return 0
end

3. 锁过期与看门狗
	•	如果线程挂了，锁会在过期时间后自动释放（避免死锁）。
	•	问题：如果业务没执行完就过期，锁会被别人抢走。
	•	解决：看门狗机制（Redisson 的实现）。
	•	加锁成功后，后台定时任务（守护线程）会定期执行 PEXPIRE 给锁续期。
	•	业务线程正常 → 锁持续有效。
	•	业务线程挂掉 → JVM 终止守护线程，锁最终过期释放。

4. 可重入锁
	•	同一线程可能多次进入临界区，需要支持重入。
	•	本地锁（如 ReentrantLock）都有计数器：重入 +1，释放 -1。
	•	Redis 分布式锁也需要类似机制。
	•	Redisson 的做法：
	•	使用 Redis Hash：
	•	Key：锁名
	•	Field：线程唯一标识（UUID + ThreadId，避免集群冲突）
	•	Value：重入计数
	•	重入时计数 +1，释放时计数 -1，直到 0 才真正释放。

5. 阻塞锁
	•	简单实现：自旋（循环重试）。
	•	Redisson 实现：
	•	没抢到锁的线程订阅一个频道并阻塞。
	•	持锁线程释放锁时，发布消息唤醒订阅者。
	•	唤醒的线程再尝试加锁。
	•	可以设置超时时间，避免无限等待。

6. 主从复制问题
	•	Redis 主从复制是异步的：
	•	客户端写入主节点成功，但主节点宕机，还没同步给从节点。
	•	从节点被提升为主 → 锁数据丢失。
	•	其他客户端可能同时拿到锁 → 违背互斥性。
	•	解决办法：多主一致加锁。

7. RedLock（红锁）
	•	Redis 作者提出的分布式锁算法。
	•	在 N 个独立 Redis 主节点上加锁，必须在超过半数的节点成功才算加锁成功。
	•	超过一定时间还没加锁成功就放弃。
	•	优点：保证多主架构下的互斥性。
	•	缺点：
	•	不同节点时钟可能不一致。
	•	JVM GC 暂停可能导致看门狗续期失败。
	•	多主节点运维复杂。
	•	所以 红锁并不常用。大多数公司：
	•	要么用 Redis 基础命令封装简单锁。
	•	要么直接用 Redisson 框架。
